Voici une version ultra-détaillée et approfondie du prompt, en insistant sur l’UI/UX (en noir et blanc strict, sans violet), l’architecture technique, et les aspects fonctionnels. Ce prompt est structuré pour que l’IA (Jules ou autre) puisse générer un code optimisé, modulaire et prêt pour la monétisation, tout en respectant tes contraintes (Kotlin, pas d’accès aux variables d’environnement, thème sombre noir et blanc).

Contexte et Vision du Projet Nom de l’Application "SwipeClean" – Une application de tri de photos/vidéos par swipe, conçue pour libérer de l’espace de stockage de manière intuitive et visuelle. Philosophie Design
Minimalisme radical : UI épurée, uniquement en noir et blanc (pas de couleurs, pas de violet). Expérience tactile : Tout est basé sur des gestes (swipe) pour une interaction fluide et naturelle. Feedback visuel clair : Animations subtiles pour confirmer les actions (ex: fondu lors de la suppression).

Public Cible

Utilisateurs soucieux de l’organisation de leur galerie mais qui n’ont pas le temps de trier manuellement. Personnes aimant les interfaces simples, sans distraction. Cible secondaire : Photographes amateurs qui veulent classer leurs médias rapidement.

Spécifications UI/UX (Noir et Blanc Strict) A. Palette de Couleurs ÉlémentCouleur HexUsageFond#000000Arrière-plan de tous les écrans.Texte principal#FFFFFFTitre, boutons, descriptions.Texte secondaire#808080Sous-titres, infos mineures.Bordures#333333Séparation des sections.Overlay#000000 + 70% opacitéMenus contextuels.Accent (boutons)#FFFFFF + bordure #333333Boutons "Commencer", "Annuler". B. Typographie
Police principale : Roboto (intégrée par défaut dans Flutter).

Taille des titres : 24px (bold). Taille du texte : 16px (regular). Sous-titres : 14px (#808080).

Espacement :

Marges : 16px entre les sections. Padding : 12px pour les boutons/cartes.

C. Composants UI Clés

Barres de Stockage (Écran d’Accueil)
Design :

Deux barres horizontales superposées verticalement. Barre 1 : Espace total vs utilisé (ex: "64 Go / 45 Go utilisés").

Fond : #333333. Partie utilisée : #FFFFFF. Texte : #000000 (pour le contraste).

Barre 2 : Espace libéré ce mois-ci (ex: "+2,3 Go").

Fond : #333333. Partie libérée : #808080.

Comportement :

Les barres se mettent à jour en temps réel après chaque action de tri.

Cartes d’Albums (Écran Albums)
Design :

Carte carrée (150x150px) avec :

Miniature : Dernière photo de l’album (recadrée en carré, filtre noir et blanc si couleur). Nom de l’album : Texte centré en bas (#FFFFFF, 16px). Bordure : 1px #333333.

Effet au double-clic : Le nom devient éditable (champ TextField avec bordure #808080).

Albums par défaut :

"Favoris" (icône ♥ en #FFFFFF). "Voyages" (icône avion en #FFFFFF). "Famille" (icône maison en #FFFFFF).

Bouton "+" :

Grisé (#333333), avec un tooltip : "Disponible en version Premium".

Écran de Swipe
Design :

Média : Occupe 90% de l’écran (hauteur et largeur), centré.

Photos : Affichées en noir et blanc (filtre appliqué dynamiquement). Vidéos : Miniature en noir et blanc + icône lecture (▶ en #FFFFFF).

Barre de progression :

En haut : "X Mo libérés" (#808080, 14px). Fond : #333333, barre de progression : #FFFFFF.

Indicateurs de geste :

Flèches discrètes en transparence (20% d’opacité) :

← (supprimer), → (conserver), ↑ (annuler), ↓ (albums).

Animations :

Swipe droit/gauche : Le média "glisse" hors de l’écran avec un effet de fondu. Swipe haut/bas : Menu contextuel apparaît en 0.3s (animation SlideTransition).

Menu des Albums (swipe bas) :

3 options (mêmes icônes que les albums). Fond : #000000 + 90% opacité. Texte : #FFFFFF.

Navigation entre Écrans
Swipe latéral :

Utiliser PageView avec PageController pour un effet de "glisse" naturel. Désactiver le swipe latéral sur l’écran de swipe (pour éviter les conflits).

Boutons de navigation :

Flèches en haut à gauche/droite (icônes #FFFFFF, 24px). Barre de tâches en bas (optionnelle) :

3 icônes : Accueil (□), Swipe (↔), Albums (●).

Spécifications Fonctionnelles Approfondies A. Écran d’Accueil (home_screen.dart)
Statistiques de Stockage
Données :

Utiliser path_provider pour récupérer :

Espace total du téléphone. Espace utilisé. Espace libéré depuis l’ouverture de l’app (stocké en mémoire via SharedPreferences).

Mise à jour :

Rafraîchir les données à chaque retour sur l’écran d’accueil.

Dernier Album Visité
Logique :

Récupérer le dernier album ouvert depuis la base de données (floor). Afficher sa miniature et son nom. Cliquable → redirige vers albums_screen.dart (avec l’album pré-sélectionné).

Boutons
"Commencer le tri" :

Bouton plein écran (hauteur : 60px, fond #FFFFFF, texte #000000). Redirige vers swipe_screen.dart.

"Voir les albums" :

Bouton secondaire (hauteur : 40px, bordure #333333, texte #808080). Redirige vers albums_screen.dart.

B. Écran de Swipe (swipe_screen.dart)

Chargement des Médias
Source :

Utiliser photo_manager pour lister photos ET vidéos. Filtres :

Exclure les dossiers système (ex: .thumb, WhatsApp). Trier par date (du plus récent au plus ancien).

Optimisation :

Charger par lots de 20 médias (pour éviter la surcharge mémoire). Cache des miniatures avec cached_network_image.

Gestes et Actions GesteActionFeedback VisuelSwipe droiteConserver le média (ne rien faire).Animation : média glisse à droite + ✓ vert (#808080).Swipe gaucheSupprimer le média (déplacer vers .SwipeClean/Trash).Animation : média glisse à gauche + ✗ rouge (#808080).Swipe hautAnnuler la dernière action (restaurer le média précédent).Toast : "Action annulée" (#FFFFFF sur fond #333333).Swipe basOuvrir le menu des albums (3 options).Menu contextuel en overlay.Tap doubleBasculer entre photo originale et noir et blanc (optionnel).Animation de fondu.
Menu des Albums (Swipe Bas)
Design :

3 boutons horizontaux (mêmes icônes que les albums). Fond : #000000 + 90% opacité. Texte : #FFFFFF.

Logique :

Sélectionner un album → le média est lié à l’album (pas de duplication de fichier). Fermeture du menu après sélection.

Barre de Progression
Calcul :

Somme des tailles des médias supprimés depuis l’ouverture de l’app. Afficher en Mo ou Go (arrondi à 1 décimale).

Réinitialisation :

Remise à zéro à chaque fermeture de l’app.

C. Écran des Albums (albums_screen.dart)

Affichage des Albums
Grille :

GridView avec 2 colonnes (espacement : 16px). Chaque carte : 150x150px (voir section UI).

Données :

Récupérer les albums depuis la base floor. Pour chaque album :

Nom. Chemin de la dernière photo ajoutée (pour la miniature).

Édition du Nom
Double-clic sur le nom → TextField apparaît. Validation :

Appuyer sur "Entrée" ou cliquer hors du champ pour sauvegarder.

Bouton "Commencer"
Logique :

Redirige vers un swipe_screen.dart spécifique à l’album :

Swipe gauche : Ajouter à l’album. Swipe droite : Passer. Swipe haut : Annuler. Swipe bas : Choisir un autre album.

Architecture Technique A. Base de Données (Floor + Kotlin)
Tables Copier-- Table Albums CREATE TABLE albums ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, cover_path TEXT, -- Chemin de la dernière photo ajoutée is_premium BOOLEAN DEFAULT FALSE, created_at DATETIME DEFAULT CURRENT_TIMESTAMP );
-- Table Medias CREATE TABLE medias ( id INTEGER PRIMARY KEY AUTOINCREMENT, path TEXT NOT NULL UNIQUE, -- Chemin original du fichier type TEXT CHECK(type IN ('photo', 'video')), album_id INTEGER, deleted_at DATETIME, -- Null si non supprimé FOREIGN KEY(album_id) REFERENCES albums(id) ); 2. Requêtes Clés

Récupérer les albums : CopierSELECT * FROM albums WHERE is_premium = FALSE OR user_is_premium = TRUE;

Médias non triés : CopierSELECT * FROM medias WHERE album_id IS NULL AND deleted_at IS NULL;

Médias d’un album : CopierSELECT * FROM medias WHERE album_id = :albumId;

B. Gestion des Fichiers

Suppression :

Déplacer les fichiers vers .SwipeClean/Trash/ (au lieu de supprimer définitivement). Suppression définitive après 30 jours (via un Worker en arrière-plan).

Restauration :

Déplacer le fichier depuis .SwipeClean/Trash/ vers son emplacement d’origine.

C. Optimisations TypeTechniqueMémoireLibérer les ressources après affichage d’un média (ex: dispose() pour les vidéos).PerformancesChargement par lots + cache des miniatures.BatterieDésactiver la lecture auto des vidéos si batterie < 20%.StockageCompresser les images > 5 Mo avant affichage.

Monétisation (Préparation) A. Flags Premium
Base de données :

Ajouter un champ user_is_premium (BOOL) dans une table users.

Fonctionnalités bloquées :

Bouton "+" pour ajouter un album → grisé + tooltip. Limite de 3 albums si user_is_premium = FALSE.

B. Intégration Future

Écran "Premium" :

Accessible via un bouton en haut à droite (icône couronne). Contenu : Avantages (albums illimités, cloud, etc.) + bouton "S’abonner".

Backend :

Prévoir une API pour vérifier l’abonnement (ex: Firebase).

Roadmap Post-MVP VersionFonctionnalitésPriorité1.1Sauvegarde cloud (Firebase Storage)Haute1.2Thèmes personnalisables (noir/gris clair)Moyenne1.3Reconnaissance de visages (ML)Basse2.0Version iOS + Sync multi-appareilsHaute

Instructions pour l’IA (Jules) A. Structure du Code Copierswipe_clean/ ├── lib/ │ ├── main.dart # Thème sombre + routage │ ├── screens/ │ │ ├── home_screen.dart # Écran d'accueil │ │ ├── swipe_screen.dart # Écran de swipe (générique) │ │ ├── swipe_album_screen.dart # Swipe pour un album spécifique │ │ └── albums_screen.dart # Écran des albums │ ├── models/ │ │ ├── album.dart # Modèle Album + DAO │ │ ├── media.dart # Modèle Media + DAO │ │ └── database.dart # Configuration Floor │ ├── widgets/ │ │ ├── storage_bar.dart # Barres de stockage │ │ ├── album_card.dart # Carte d'album │ │ ├── media_card.dart # Carte de média (swipe) │ │ └── swipe_menu.dart # Menu contextuel (swipe bas) │ ├── utils/ │ │ ├── constants.dart # Noms des albums, chemins, etc. │ │ ├── file_utils.dart # Gestion des fichiers (déplacement, suppression) │ │ └── theme.dart # Thème sombre noir et blanc │ └── app_router.dart # Gestion de la navigation ├── assets/ │ └── icons/ # Icônes en SVG/PNG (noir et blanc) └── pubspec.yaml # Dépendances (Kotlin uniquement) B. Dépendances Flutter (Kotlin) Copierdependencies: flutter: sdk: flutter

Kotlin-compatible
path_provider: ^2.1.1 photo_manager: ^2.1.0 floor: ^1.4.0 video_thumbnail: ^0.5.0 cached_network_image: ^3.3.0 shared_preferences: ^2.2.0 flutter_swipe_action: ^2.0.0 C. Étapes de Développement

Configurer le thème sombre (theme.dart) :

Couleurs : #000000, #FFFFFF, #333333, #808080. Polices : Roboto (bold/regular).

Implémenter la base de données (database.dart) :

Créer les tables albums et medias avec floor. Ajouter des méthodes pour :

Lister les albums. Ajouter/supprimer un média. Restaurer un média.

Créer les widgets réutilisables :

StorageBar : Barres de stockage (accueil). AlbumCard : Carte d’album (éditable). MediaCard : Carte de média avec gestes de swipe.

Développer les écrans :

home_screen.dart :

Barres de stockage (mises à jour dynamiques). Boutons "Commencer le tri" et "Voir les albums".

swipe_screen.dart :

Chargement des médias non triés. Logique des swipes (droite/gauche/haut/bas). Barre de progression.

albums_screen.dart :

Grille des albums. Double-clic pour éditer le nom. Bouton "Commencer" pour chaque album.

Gérer la navigation (app_router.dart) :

Utiliser PageView pour le swipe entre écrans. Désactiver le swipe latéral sur swipe_screen.dart.

Tests et Validation :

Vérifier que :

Les swipes ne buggent pas. Les médias supprimés vont dans la corbeille. La restauration fonctionne. Les albums s’affichent correctement.

D. Points d’Attention pour l’IA

Pas de couleurs : Tout doit être en noir (#000000), blanc (#FFFFFF), ou gris (#333333, #808080). Gestes prioritaires :

Le swipe haut doit toujours annuler la dernière action (même sur l’écran de swipe d’un album).

Pas de duplication de fichiers :

Les médias dans les albums sont des liens symboliques (ou chemins référencés).

Corbeille :

Les fichiers supprimés sont déplacés, pas effacés. Prévoir un Worker pour vider la corbeille après 30 jours.

E. Questions pour l’IA

Faut-il ajouter un mode "sélection multiple" pour supprimer plusieurs médias d’un coup ? Comment gérer les vidéos longues (ex: > 1 min) pour éviter de charger trop de données ? Veux-tu que je génère aussi les icônes en noir et blanc pour les albums ? Dois-je prévoir un système de logs pour déboguer les erreurs de suppression ?

Exemple de Code (Extrait) A. Thème Sombre (theme.dart) Copierimport 'package:flutter/material.dart';
final darkTheme = ThemeData( brightness: Brightness.dark, primaryColor: const Color(0xFF000000), scaffoldBackgroundColor: const Color(0xFF000000), textTheme: const TextTheme( headline1: TextStyle(color: Color(0xFFFFFFFF), fontSize: 24, fontWeight: FontWeight.bold), bodyText1: TextStyle(color: Color(0xFFFFFFFF), fontSize: 16), bodyText2: TextStyle(color: Color(0xFF808080), fontSize: 14), ), iconTheme: const IconThemeData(color: Color(0xFFFFFFFF)), buttonTheme: ButtonThemeData( buttonColor: const Color(0xFFFFFFFF), textTheme: ButtonTextTheme.primary, ), ); B. Widget StorageBar (storage_bar.dart) Copierclass StorageBar extends StatelessWidget { final double totalSpace; // en Go final double usedSpace; final double freedSpace;

const StorageBar({ required this.totalSpace, required this.usedSpace, required this.freedSpace, });

@override Widget build(BuildContext context) { return Column( children: [ // Barre 1 : Espace total/utilisé _buildProgressBar( value: usedSpace / totalSpace, label: '${usedSpace.toStringAsFixed(1)} Go / ${totalSpace.toStringAsFixed(1)} Go', color: Colors.white, ), const SizedBox(height: 8), // Barre 2 : Espace libéré _buildProgressBar( value: freedSpace / totalSpace, label: '+${freedSpace.toStringAsFixed(1)} Go libérés', color: Colors.grey[500]!, ), ], ); }

Widget _buildProgressBar({required double value, required String label, required Color color}) { return Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(label, style: Theme.of(context).textTheme.bodyText2), const SizedBox(height: 4), LinearProgressIndicator( value: value, backgroundColor: const Color(0xFF333333), valueColor: AlwaysStoppedAnimation

Validation et Livrables A. Critères de Validation CritèreMéthode de TestSwipes fonctionnelsTester tous les gestes sur 10 médias.Barres de stockage mises à jourSimuler la suppression de 1 Go.Albums éditablesDouble-cliquer sur un nom d’album.Restauration des médiasSwipe haut après une suppression.Pas de duplication de fichiersVérifier le chemin des médias dans les albums. B. Livrables
Code source complet (dossier lib/). Fichier pubspec.yaml avec dépendances Kotlin. Documentation :

Comment ajouter un nouvel album (pour la version premium). Comment étendre la corbeille à 1 an.

Capture d’écran des 3 écrans (pour validation visuelle).

Prochaines Étapes (Pour Toi, Sacha)
Valider le design UI : Je peux te générer des maquettes Figma en noir et blanc si besoin. Tester le MVP :

Vérifier que les swipes sont fluides. Confirmer que l’UI est bien en noir et blanc.

Planifier les fonctionnalités premium :

Quels avantages veux-tu offrir en priorité (cloud ? thèmes ?) ? et voici le prompt pas structuré Salut, je vais faire une appli en Flutter d'Art et je veux que toutes les dépendances soient en Kotlin. Parce que je suis sur le PC du lycée, je ne peux pas accéder aux paramètres de variables d'environnement. Je ne peux pas activer le mode développeur sur l'ordinateur. Donc tout ce que tu le feras, prends ça en compte de ça. Tu vas prendre mon repo dans lequel il y a déjà un projet de base Flutter et tu auras juste à éditer les fichiers que tu auras besoin pour créer mon application. Ce sera une application de tri de photos par swipe. qui va se baser sur le swiping pour nettoyer le téléphone, pour les photos et les vidéos. N'oublie pas les vidéos. On aura trois écrans, l'écran d'accueil, l'écran de swipe à droite de l'écran d'accueil qui sera au milieu, et à gauche on a l'écran de... Dans l'écran des albums, il y a trois albums. Dans l'écran d'accueil, il y a les statistiques, donc l'espace de stockage total sous forme de barre horizontale avec l'espace de stockage consommé, donc tout ça sous forme de barre horizontale. En dessous, une deuxième barre où il y aura l'espace de stockage libéré ce mois-ci. En dessous on aura le dernier album visité et tout en dessous on aura un bouton commencer le tri ou juste au dessus un bouton légèrement plus petit et d'un contre intéressé pour voir les albums. A droite de cela on aura l'écran, quand on cliquera sur commencer le tri on tombera sur l'écran de swipe ou dans la barre de tâche ou sinon avec les flèches en haut des écrans il y aura des flèches pour accéder à tous les écrans. On va aussi également glisser entre les écrans en juste avec des mouvements latéraux du doigt donc en swipant on peut passer d'écran. Sur l'écran de swipe, on ne peut pas se déplacer parce qu'on swipe déjà. Sur l'écran de swipe, tu swipes à droite, ça garde la photo. Tu swipes à gauche, ça supprime. Tu swipes vers le haut, ça restaure la photo qu'on avait juste avant. Tu swipes vers le bas, ça te met un menu déroulant avec les trois albums. Tu sélectionnes l'album, ça met la photo dans l'album. On aura une photo qui sera au maximum cadrée sur le téléphone, donc je veux qu'elle prenne un maximum de place avec presque rien comme écriture. Et juste en haut, on aura la barre de progression de combien on a déjà libéré en swipant depuis que l'application a été ouverte. Donc par exemple, si je la ferme dans mon téléphone, ça remettra cette barre à zéro. On aura également l'écran avec les albums, avec 3 albums par défaut et un bouton plus grisé qu'on ne pourra pas ajouter parce que ce sera la version payante. Également, sur l'écran de l'album, on peut double-cliquer sur un album pour modifier le nom. L'album affichera la dernière photo qu'on a mise. Il affichera une photo qu'on choisit en fond d'écran, mais par défaut il affichera la dernière photo qu'on a mise. Et quand on va dans l'album, on peut soit tout en bas, il y a un bouton « Commencer » ajouté à cet album, on retombe sur un écran de swipe et là tu swipes à gauche, ça met sur cet album, tu swipes à droite, ça passe, tu swipes vers le haut, ça restaure la photo que nous avons montrée juste avant. en annulant les changements apportés à cette photo bien sûr. Et pareil pour l'écran de swipe normal, quand on swipe vers le haut, ça annule les changements qu'on a apportés sur cette photo en swipant juste avant. Tout ça c'est clair, pour lui, fais tout ça juste en noir et blanc pour l'instant, en thème sombre, après moi je te montrerai comment faire pour lui. D'accord ?



Décisions confirmées :

Suppression : Les médias sont déplacés vers une corbeille (dans Firebase Storage) avec possibilité de restauration via swipe haut.
Base de données : Firestore (remplace SQLite/Floor) avec synchronisation en temps réel et cache local activé.
Albums : Utilisation de références dans Firestore (pas de duplication de fichiers).
Stockage : Firebase Storage pour les médias et la corbeille, avec règles de sécurité pour limiter l’accès aux fichiers de l’utilisateur.
Authentification : Firebase Auth (email/mot de passe + Google Sign-In).
1. Initialisation du Projet Flutter
Créer un nouveau projet Flutter avec support Android.
Configurer pubspec.yaml :
yaml
 Copier
dependencies:
  flutter:
    sdk: flutter
  firebase_core: ^2.15.0
  firebase_auth: ^4.7.0
  cloud_firestore: ^4.8.0
  firebase_storage: ^11.2.0
  photo_manager: ^2.6.0
  video_thumbnail: ^0.5.3
  cached_network_image: ^3.3.0
  permission_handler: ^10.4.0
  shared_preferences: ^2.2.1
  provider: ^6.0.5
  flutter_bloc: ^8.1.3  # Pour la gestion d'état robuste
  logger: ^2.0.2        # Pour les logs détaillés
Ajouter les permissions Android dans AndroidManifest.xml :
xml
 Copier
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" />
<!-- Pour Android 13+ -->
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
<uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
Configurer le SDK minimum Android à 21 et target SDK à 33.
Définir le thème sombre global avec palette noir et blanc stricte.
2. Système de Thème et Constantes
Créer le fichier theme.dart avec ThemeData en mode sombre.
Couleurs :
Fond : #000000
Texte : #FFFFFF
Gris foncé : #333333
Gris clair : #808080
Polices : Roboto (bold 24px, regular 16px, light 14px).
Constantes d’espacement : marges 16px, padding boutons 12px.
Albums par défaut : Favoris, Voyages, Famille.
3. Modèles de Données et Firestore
Modèle Album :
dart
 Copier
class Album {
  final String id;          // ID Firestore
  final String name;
  final String? coverPath;  // Chemin dans Firebase Storage
  final bool isPremium;
  final DateTime createdAt;
  final String userId;     // Référence à l'utilisateur (Firebase Auth UID)
}
Modèle Media :
dart
 Copier
enum MediaType { photo, video }

class Media {
  final String id;          // ID Firestore
  final String originalPath; // Chemin dans Firebase Storage
  final MediaType type;
  final String? albumId;   // Référence à un Album (nullable)
  final DateTime? deletedAt;
  final int size;          // Taille en octets
  final String userId;     // Référence à l'utilisateur
}
Configuration Firestore :
Activer le cache persistant pour le mode hors ligne.
Règles de sécurité :
javascript
 Copier
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
Collections :
users/{userId}/albums
users/{userId}/media
users/{userId}/trash (pour les médias supprimés)
4. Services de Gestion des Fichiers (avec Firebase Storage)
Créer FileService :
moveToTrash(Media media) :
Déplacer le fichier vers gs://[BUCKET]/users/${userId}/trash/${media.id} dans Firebase Storage.
Mettre à jour deletedAt dans Firestore.
Gestion des erreurs :
Vérifier la connexion internet avant l’opération.
Si échec, stocker l’action en local (via SharedPreferences) et synchroniser plus tard.
restoreFromTrash(Media media) :
Restaurer le fichier depuis la corbeille vers son emplacement d’origine.
Mettre à jour deletedAt à null dans Firestore.
deleteDefinitively(Media media) :
Supprimer physiquement le fichier de Firebase Storage.
Supprimer l’entrée dans Firestore.
Gestion des erreurs :
FirebaseException : Afficher un SnackBar avec un message clair et proposer une réessayer.
Fichier introuvable : Marquer le média comme "corrompu" dans Firestore et passer au suivant.
5. Service de Gestion du Stockage
Créer StorageService :
getTotalSpace() : Utiliser path_provider pour l’espace local + Firebase Storage pour l’espace cloud.
getUsedSpace() : Calculer la somme des tailles des médias dans Firestore.
getFreedSpaceThisMonth() : Stocker dans SharedPreferences et synchroniser avec Firestore.
getCurrentSessionFreed() : Variable en mémoire, sauvegardée périodiquement.
Formater les tailles en Go/Mo avec 1 décimale.
6. Service de Gestion des Médias
Créer MediaService :
Utiliser photo_manager pour lister les médias locaux.
Filtrer les dossiers système (.thumbnails, .trash, etc.).
Trier par date décroissante.
Charger par lots de 20 médias pour optimiser la mémoire.
Générer les miniatures avec video_thumbnail et les uploader dans Firebase Storage (dossier thumbnails).
Cache : Utiliser cached_network_image pour les miniatures, avec une limite de 100 Mo.
7. Widget StorageBar
Deux LinearProgressIndicator superposés :
Barre supérieure : Espace utilisé (X Go / Y Go).
Barre inférieure : Espace libéré ce mois (+X Go libérés).
Animations : duration: 0.5s.
Couleurs : Fond #333333, barres #FFFFFF et #808080.
8. Widget AlbumCard
Carte 150x150px avec bordure #333333.
Miniature : Dernière photo de l’album (ou icône par défaut).
Nom de l’album : Éditable via double-clic, sauvegardé dans Firestore au onSubmitted.
Fallback : Si l’album est vide, afficher une icône par défaut (♥, ✈, 🏠).
9. Widget MediaCard
Affichage plein écran (90% hauteur/largeur).
Indicateurs de geste : ← (supprimer), → (garder), ↑ (annuler), ↓ (albums).
Gestion des erreurs :
Si le média ne charge pas, afficher une icône ⚠️ et un bouton "Réessayer".
Utiliser CircularProgressIndicator pendant le chargement.
10. Widget SwipeMenu
Overlay modal avec 3 albums (icônes ♥, ✈, 🏠).
Animation : SlideTransition depuis le bas (duration: 0.3s).
Bouton "Annuler" en gris en haut à droite.
11. Écran d’Accueil (HomeScreen)
StorageBar en haut.
Section "Dernier album visité" : Récupéré depuis SharedPreferences.
Boutons :
"Commencer le tri" → SwipeScreen.
"Voir les albums" → AlbumsScreen.
Rafraîchir les stats avec FutureBuilder à chaque ouverture.
12. Écran de Swipe Principal (SwipeScreen)
Stack : Média + indicateurs + barre de progression.
Gestion des swipes :
Droite : Passer au média suivant.
Gauche : Déplacer vers la corbeille (Firebase Storage + Firestore).
Haut : Annuler la dernière action (via pile d’historique).
Bas : Afficher SwipeMenu.
Pile d’historique : 10 actions max, stockée en mémoire et synchronisée avec Firestore.
13. Écran des Albums (AlbumsScreen)
GridView avec 2 colonnes.
Albums par défaut : Chargés depuis Firestore.
Bouton "+" : Grisé si user_is_premium == false (limite à 3 albums).
Tooltip : "Disponible en version Premium".
14. Écran de Swipe pour Album (AlbumSwipeScreen)
Même structure que SwipeScreen, mais :
Swipe gauche : Assigner le média à l’album (mettre à jour albumId dans Firestore).
Compteur : "X photos ajoutées" au lieu de l’espace libéré.
15. Navigation Entre Écrans
PageView avec 3 pages : AlbumsScreen, HomeScreen, SwipeScreen.
Désactiver PageView sur SwipeScreen et AlbumSwipeScreen.
Sauvegarder le dernier album visité dans SharedPreferences.
16. Gestion de l’Historique et Restauration
Classe HistoryAction :
dart
 Copier
class HistoryAction {
  final String actionType; // 'delete', 'assign', 'unassign'
  final String mediaId;
  final String? previousAlbumId;
  final DateTime timestamp;
}
Pile de 10 actions max, stockée en mémoire et synchronisée avec Firestore.
Swipe haut : Dépiler la dernière action et effectuer l’opération inverse.
17. Optimisations de Performance
Lazy loading : Pré-charger 3 médias en avance.
AutomaticKeepAliveClientMixin pour les pages du PageView.
Compression : Utiliser flutter_image_compress pour les images > 5 Mo.
compute() pour les opérations lourdes (ex : génération de miniatures).
18. Gestion des Permissions Android
Demander les permissions au démarrage avec permission_handler.
Android 13+ : READ_MEDIA_IMAGES et READ_MEDIA_VIDEO.
Android 10-12 : READ_EXTERNAL_STORAGE et WRITE_EXTERNAL_STORAGE.
Dialogue explicatif si refus, redirection vers les paramètres si nécessaire.
19. Préparation Monétisation
user_is_premium dans SharedPreferences (défaut : false).
Limiter à 3 albums si non premium.
Bouton "+" grisé et désactivé si limite atteinte.
TODO : Préparer l’écran PremiumScreen et les intégrations de paiement (Stripe/Firebase In-App Purchases).
20. Animations et Feedback Visuel
Transitions : AnimatedSwitcher (300ms).
Swipe gauche/droite : Transform.translate + FadeTransition.
Restauration : Animation de scale (0.8 → 1.0).
Effet ripple sur les boutons.
21. Gestion des Erreurs et Edge Cases (Stratégie Renforcée)
A. Principes Généraux
Approche "Defensive Programming" :

Toujours valider les entrées/sorties (ex : mediaId existe dans Firestore avant toute opération).
Utiliser des assertions et des logs détaillés (logger package).
Ne jamais planter : Toujours afficher un message clair et proposer une action (ex : "Réessayer", "Ignorer").
Gestion des Exceptions :

Centraliser avec un ErrorHandler global :
dart
 Copier
class ErrorHandler {
  static void handleError(dynamic error, StackTrace stackTrace) {
    Logger().e('Erreur capturée', error: error, stackTrace: stackTrace);
    // Afficher un SnackBar ou rediriger vers un écran d'erreur
  }
}
Types d’erreurs à gérer :
FirebaseException (ex : pas de connexion internet).
PlatformException (ex : permission refusée).
FileSystemException (ex : fichier introuvable).
StateError (ex : pile d’historique vide).
Logs et Debugging :

Logger : Sauvegarder les logs localement et les envoyer à Firebase Crashlytics.
Identifiants uniques pour les erreurs (ex : ERROR_001: Permission refusée).
B. Erreurs par Module

Module
Erreurs Possibles
Solutions
Firestore
Connexion perdue, requête trop lente
Utiliser le cache local, réessayer avec exponential backoff.
Firebase Storage
Fichier introuvable, quota dépassé
Marquer le média comme "corrompu", afficher un SnackBar.
Permissions
Refus de l’utilisateur
Rediriger vers les paramètres, afficher un écran "Mode limité".
Médias
Fichier corrompu, miniature non générée
Afficher une icône par défaut, passer au média suivant.
UI/UX
Geste ambigu, état incohérent
Désactiver les boutons si nécessaire, ignorer les swipes diagonaux.
C. Exemple de Code Robuste
dart
 Copier
Future<void> moveToTrash(Media media) async {
  try {
    // 1. Vérifier la connexion internet
    final hasConnection = await _connectivity.checkConnectivity();
    if (hasConnection == ConnectivityResult.none) {
      throw const NoInternetError();
    }

    // 2. Déplacer le fichier vers Firebase Storage
    final trashRef = FirebaseStorage.instance
        .ref()
        .child('users/${media.userId}/trash/${media.id}');
    await trashRef.putFile(File(media.originalPath));

    // 3. Mettre à jour Firestore
    await FirebaseFirestore.instance
        .collection('users/${media.userId}/media')
        .doc(media.id)
        .update({'deletedAt': FieldValue.serverTimestamp()});

    // 4. Mettre à jour les stats
    _storageService.incrementFreedSpace(media.size);
  } on FirebaseException catch (e) {
    ErrorHandler.handleError(e, StackTrace.current);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Erreur Firebase: ${e.message}')),
    );
    rethrow; // Permet au caller de gérer l'erreur si nécessaire
  } on NoInternetError {
    // Sauvegarder l'action pour synchronisation ultérieure
    await _localQueue.addAction('moveToTrash', media.toJson());
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Action sauvegardée. Synchronisation dès que possible.')),
    );
  } catch (e) {
    ErrorHandler.handleError(e, StackTrace.current);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Une erreur est survenue (Code: ERROR_002)')),
    );
  }
}
22. Tests et Validation
Tests Unitaires :
Couvrir 100% des cas d’erreur dans FileService, MediaService.
Utiliser mockito pour simuler des scénarios (ex : pas de connexion, fichier introuvable).
Tests d’Intégration :
Tester les flux complets (ex : swipe gauche → suppression → restauration).
Vérifier la cohérence de Firestore après chaque action.
Tests Utilisateurs :
Scénarios : suppression de 100 photos, passage en arrière-plan, changement de permissions.
23. Monitoring et Amélioration Continue
Firebase Crashlytics : Intégrer pour suivre les plantages.
Firebase Analytics : Suivre les erreurs fréquentes et les actions utilisateur.
Mises à jour :
Prévoir un système de hotfix (ex : correction via Firestore Remote Config).
Utiliser package_info_plus pour forcer les mises à jour critiques.
24. Checklist Pré-Livraison

Catégorie
Vérifications
Firebase
✅ Règles de sécurité configurées, cache activé, quotas vérifiés.
Stockage
✅ Permissions gérées, fallbacks pour les fichiers introuvables.
UI/UX
✅ Feedback clair, gestes précis, états cohérents.
Tests
✅ 100% des cas d’erreur couverts, tests utilisateurs passés.
Monitoring
✅ Crashlytics et Analytics configurés, logs sauvegardés.
